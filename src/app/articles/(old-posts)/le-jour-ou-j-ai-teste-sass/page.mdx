import MdxLayout from '@/layouts/mdx-layout';

export const metadata = {
  title: 'Le jour oÃ¹ jâ€™ai testÃ© Sass',
  description:
    'Retour dâ€™expÃ©rience sur ma premiÃ¨re expÃ©rience approfondie de Sass.',
  date: '2012-10-15T00:00:00Z',
};

Jâ€™ai lu rÃ©cemment pas mal de dÃ©bats sur lâ€™intÃ©rÃªt dâ€™intÃ©grer ou non les prÃ©processeurs CSS dans nos workflows. Certains pour, dâ€™autres contre, bref, les avis semblaient vraiment partagÃ©s sur le sujet. Dâ€™aprÃ¨s ce que jâ€™avais pu en lire, ils pouvaient pourtant prÃ©senter un rÃ©el intÃ©rÃªt dans certains cas, notamment sur de gros projets. Curieux dâ€™en savoir un peu plus sur le sujet, jâ€™ai rÃ©cemment plongÃ© mon nez dans Sass, qui semblait le plus populaire des diffÃ©rents prÃ©processeurs.

## Sass en quelques mots

[Sass](http://sass-lang.com/) est, dixit son site officiel, une extension de CSS3 qui permet dâ€™introduire de nouveaux concepts au sein de CSS : variables, imbrication dâ€™Ã©lÃ©ments, hÃ©ritage de sÃ©lecteurs etc. La syntaxe utilisÃ©e est le SCSS (pour Sassy CSS), qui permet de crÃ©er des fichiers .scss facilement convertibles en fichiers .css au moyen de lâ€™outil de commande en ligne ou par le biais dâ€™apps.

## Comment lâ€™installer ?

Le site officiel prÃ©conise dâ€™utiliser Ruby (installÃ© par dÃ©faut sous Mac, Ã  [installer](http://rubyinstaller.org/downloads/) sous Windows). On installe ensuite Sass avec la commande `gem install sass`. On crÃ©e un fichier SCSS, par exemple `style.scss` et on le "surveille" avec `sass --watch style.scss:style.css`.

Ou sinon, pour les paresseux (dont je fais partie) on installe un logiciel qui fait automatiquement le boulot; en voici une petite liste :

- [Codekit](http://incident57.com/codekit/) (Mac, payant)
- [Prepros](http://alphapixels.com/prepros/) (Windows, gratuit)
- [Compass.app](http://compass.handlino.com/) (Windows, payant)

## Les avantages de Sass

La page dâ€™accueil de Sass en dÃ©nombre 4. Il suffit en effet de les mettre en pratique pour rapidement comprendre la puissance de lâ€™outil, et son Ã©norme potentiel lors de la rÃ©alisation de projets complexesâ€¦ Regardons Ã§a un peu plus en dÃ©tails :

### Nesting

Le nesting, quâ€™on pourrait plus ou moins traduire par imbrication, permet de regrouper ensemble plusieurs sÃ©lecteurs en les imbriquant pour plus de clartÃ©. Par exemple, prenons le SCSS suivant :

```scss
ul {
  padding: 2em;
  a {
    color: white;
  }
}
```

Il se traduira en CSS par :

```css
ul {
  padding: 2em;
}

ul a {
  color: white;
}
```

Le nesting est donc un bon moyen dâ€™organiser clairement ses informations. Par ailleurs, il marche non seulement avec les sÃ©lecteurs mais Ã©galement avec leurs propriÃ©tÃ©s.

### Variables

Sass permet dâ€™intÃ©grer la notion de variables en CSS, variables qui peuvent Ãªtre couplÃ©es avec certaines opÃ©rations mathÃ©matiques ou fonctions : on peut ainsi dÃ©finir une variable `$couleur`, qui correspondra par exemple Ã  la couleur principale de notre site, puis styler certains Ã©lÃ©ments Ã  partir de celle-ci en les rendant lÃ©gÃ¨rement plus clairs : `lighten($couleur, 10%)`. Il suffit ensuite de changer la valeur de notre variable `$couleur` pour quâ€™automatiquement les autres propriÃ©tÃ©s dÃ©pendant de celle-ci se mettent Ã  jour.

### Les @mixins

Ils permettent de rÃ©utiliser une partie de notre CSS nâ€™importe oÃ¹ grÃ¢ce Ã  la fonction `@include`. Ainsi le SCSS suivant :

```scss
@mixin list-padd {
  ul {
    padding: 2em;
  }
  li {
    padding: 1em;
  }
}

nav {
  @include list-padd;
}
```

Sera traduit en CSS par :

```css
nav ul {
  padding: 2em;
}

nav li {
  padding: 1em;
}
```

Simple non ? ğŸ™‚

### HÃ©ritage de sÃ©lecteurs

Fonctionnant un peu sur le mÃªme principe que les `@mixins`, la fonction `@extend` permet dâ€™Ã©tendre les styles dâ€™un sÃ©lecteur Ã  un autre. Par exemple, le SCSS suivant :

```scss
.red {
  color: white;
  background: red;
}

.button {
  padding: 2em;
  @extend .red;
}
```

donnera ce CSS :

```css
.red,
.button {
  color: white;
  background: red;
}

.button {
  padding: 2em;
}
```

Une fonction pratique donc, qui permet dâ€™Ã©viter dâ€™avoir Ã  copier/coller 20 fois le mÃªme code au moindre changement.

## En conclusionâ€¦

â€¦ Lâ€™essayer, câ€™est lâ€™adopter ! Plus sÃ©rieusement, aprÃ¨s quelques temps dâ€™utilisation, Sass mâ€™apparaÃ®t comme un outil indispensable lors de la rÃ©alisation de projets complexes. Les outils quâ€™il intÃ¨gre permettent Ã  mon sens de rationaliser et optimiser trÃ¨s fortement notre workflow. Il prÃ©sente en revanche peut-Ãªtre moins dâ€™intÃ©rÃªt sur des projets plus petits, quoiqueâ€¦

Par ailleurs, je nâ€™ai citÃ© quâ€™une partie de ses possibilitÃ©s, pour plus dâ€™informations sur son potentiel je vous invite Ã  consulter son trÃ¨s riche [fichier de rÃ©fÃ©rence](http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html).

Pour terminer sur les prÃ©processeurs, sachez quâ€™il en existe dâ€™autres, et notamment [LESS](http://lesscss.org/), que je nâ€™ai pas eu lâ€™occasion de tester. [Chris Coyier](http://chriscoyier.net/) a dâ€™ailleurs rÃ©digÃ© un [comparatif sur le sujet](http://css-tricks.com/sass-vs-less/), dÃ©signant plus ou moins Sass comme la version gagnante par rapport Ã  LESSâ€¦

Enfin, si vous voulez peser le pour et le contre de lâ€™utilisation des prÃ©processeurs, je vous invite Ã  lire ces deux articles : [PrÃ©processeurs CSS : renoncer par choix, ou par ignorance ?](http://blog.kaelig.fr/post/24877648508/preprocesseurs-css-renoncer-par-choix-ou-par), et [Why Iâ€™m still against Sass/LESS](http://www.amberweinberg.com/why-im-still-against-sass-less/).

export default function MdxPage({ children }) {
  return <MdxLayout metadata={metadata}>{children}</MdxLayout>;
}
