---
title: 'Using Utility-first CSS to create fluid interfaces'
description: 'This article shows how a few lines of JavaScript can help build a small, yet solid CSS framework to handle fluid UIs.'
date: 2020-05-01T00:00:00Z
path: '/articles/using-utility-first-css-to-create-fluid-interface/'
---

import ArticleOverflowContent from 'components/ArticleOverflowContent';
import FluidResize from 'videos/fluid-resize.mp4';
import ResponsiveResize from 'videos/responsive-resize.mp4';

It’s been only a few days since I [last wrote](/articles/react-and-atomic-css/) about the power of Atomic / Utility-first CSS, but I feel like there is plenty left to say about that methodology and how it has become more and more popular over the last years. Frameworks based on it have been widly adopted: Tailwind has [22.2k](https://github.com/tailwindcss/tailwindcss) stars on GitHub, while Tachyons is close to [10k](https://github.com/tachyons-css/tachyons/) stars. New technologies have emerged: Atomic CSS-in-JS seems to be a thing now with libraries such as [Styletron](https://github.com/styletron/styletron), [cxs](https://github.com/cxs-css/cxs/) or [Fela](https://github.com/robinweser/fela).

However, despite the maturity of the concept, I feel like there are a few blank spaces left around it. One of them is what I call _fluid user inferfaces_.

## A word on fluid UIs

I first read about that idea a few years ago, in an article called [Responsive And Fluid Typography With vh And vw Units](https://www.smashingmagazine.com/2016/05/fluid-typography/), published in [Smashing Magazine](https://www.smashingmagazine.com/). As its title implies, it was however only focused on typography. Here’s the gist of it:

> Unlike responsive typography, which changes only at set breakpoints, fluid typography resizes smoothly to match any device width. It is an intuitive option for a web in which we have a practically infinite number of screen sizes to support.

A fluid interface basically follows that exact same principle, but extends it to other CSS properties which values are most likely to change with screen size: `margin`, `padding`, `width`, `height` etc.

Using such a methodology ensures that CSS values won’t “jump” when reaching a breakpoint, thus offering a better rendering on different viewports:

<ArticleOverflowContent className="d-grid sm:g-2">
  <div>
    <figure>
      <video className="d-block w-100p" controls>
        <source src={ResponsiveResize} type="video/mp4" />
      </video>
      <figcaption>Responsive interface</figcaption>
    </figure>
  </div>
  <div>
    <figure>
      <video className="d-block w-100p" controls>
        <source src={FluidResize} type="video/mp4" />
      </video>
      <figcaption>Fluid interface</figcaption>
    </figure>
  </div>
</ArticleOverflowContent>

In the side-by-side comparison above, we clearly see the benefits of a fluid UI: font-sizes and spacings are dynamically adjusted, content won’t suddenly become bigger when reaching a new breakpoint.

## The power of calc()

At its core, a fluid CSS property is based on a mathematic formula powered by the `calc()` CSS function and the `vw` unit:

<figure>
  <img
    src="../../images/advanced-calc-800-opt.png"
    alt="Fluid CSS calculation"
  />
  <figcaption>Illustration &copy; Smashing Magazine</figcaption>
</figure>

Four values need to be defined in order to make it work: minimum/maximum CSS values, and minimum/maximum breakpoints. With that formula, we tell the browser that we want our text to have a `font-size` of 16 pixels at `400px`, 24 pixels at `800px`, and that it needs to adjust fluidly in-between.
